import { useState, useCallback } from 'react'
import { useContentRouter } from '@/features/content-router/hooks/useContentRouter'
import { useSonarrStore } from '@/features/sonarr/store/sonarrStore'
import type {
  ContentRouterRule,
  ContentRouterRuleUpdate,
} from '@root/schemas/content-router/content-router.schema'

export function useSonarrContentRouter() {
  const contentRouter = useContentRouter({ targetType: 'sonarr' })
  const [localRules, setLocalRules] = useState<
    (Partial<ContentRouterRule> & { tempId: string })[]
  >([])
  const [savingRules, setSavingRules] = useState<{ [key: string]: boolean }>({})
  const [deleteConfirmationRuleId, setDeleteConfirmationRuleId] = useState<
    number | null
  >(null)

  // Get Sonarr instances and genres from the store
  const instances = useSonarrStore((state) => state.instances)
  const genres = useSonarrStore((state) => state.genres)
  const fetchGenres = useSonarrStore((state) => state.fetchGenres)

  // Handler for genre dropdown opening
  const handleGenreDropdownOpen = useCallback(async () => {
    if (!genres?.length) {
      try {
        await fetchGenres()
      } catch (error) {
        console.error('Failed to fetch genres:', error)
      }
    }
  }, [genres, fetchGenres])

  // Add a temporary rule to local state
  const handleAddRule = useCallback(() => {
    setLocalRules((prev) => [
      ...prev,
      {
        tempId: `temp-${Date.now()}`,
        target_type: 'sonarr',
      },
    ])
  }, [])

  // Save a new rule
  const handleSaveNewRule = useCallback(
    async (
      tempId: string,
      data: ContentRouterRule | ContentRouterRuleUpdate,
    ) => {
      setSavingRules((prev) => ({ ...prev, [tempId]: true }))

      try {
        // Remove any properties that should be generated by the server
        const { id, created_at, updated_at, ...ruleData } = data as any

        // Create the rule
        await contentRouter.createRule(ruleData)

        // Remove from local rules
        setLocalRules((prev) => prev.filter((r) => r.tempId !== tempId))
      } catch (error) {
        console.error('Failed to create content routing rule:', error)
      } finally {
        setSavingRules((prev) => {
          const updated = { ...prev }
          delete updated[tempId]
          return updated
        })
      }
    },
    [contentRouter],
  )

  // Update an existing rule
  const handleUpdateRule = useCallback(
    async (id: number, data: ContentRouterRuleUpdate) => {
      setSavingRules((prev) => ({ ...prev, [id]: true }))

      try {
        await contentRouter.updateRule(id, data)
      } catch (error) {
        console.error('Failed to update content routing rule:', error)
      } finally {
        setSavingRules((prev) => {
          const updated = { ...prev }
          delete updated[id]
          return updated
        })
      }
    },
    [contentRouter],
  )

  // Remove a rule
  const handleRemoveRule = useCallback(async () => {
    if (deleteConfirmationRuleId !== null) {
      try {
        await contentRouter.deleteRule(deleteConfirmationRuleId)
        setDeleteConfirmationRuleId(null)
      } catch (error) {
        console.error('Failed to delete content routing rule:', error)
      }
    }
  }, [contentRouter, deleteConfirmationRuleId])

  // Cancel adding a new rule
  const handleCancelLocalRule = useCallback((tempId: string) => {
    setLocalRules((prev) => prev.filter((r) => r.tempId !== tempId))
  }, [])

  return {
    // Pass through state and methods from the content router hook
    rules: contentRouter.rules,
    isLoading: contentRouter.isLoading,
    error: contentRouter.error,
    fetchRules: contentRouter.fetchRules,

    // Local state
    localRules,
    savingRules,
    deleteConfirmationRuleId,

    // Local methods
    handleAddRule,
    handleSaveNewRule,
    handleUpdateRule,
    handleRemoveRule,
    handleCancelLocalRule,
    handleGenreDropdownOpen,
    setDeleteConfirmationRuleId,

    // Context
    instances,
    genres,
  }
}
